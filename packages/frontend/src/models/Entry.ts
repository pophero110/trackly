import { generateId } from '../utils/helpers.js';
import { IEntry, IEntryTag, EntryFormData } from '../types/index.js';
import { Tag } from './Tag.js';

/**
 * Entry model representing a logged measurement with multiple tags
 */
export class Entry implements IEntry {
    id: string;
    tags: IEntryTag[];
    title: string;
    timestamp: string;
    value?: string | number | boolean;
    valueDisplay?: string;
    notes: string;
    latitude?: number;
    longitude?: number;
    locationName?: string;
    isArchived?: boolean;
    createdAt: string;

    constructor(data: Partial<IEntry> & { title: string; timestamp: string }) {
        // ID will be generated by the server if not provided
        this.id = data.id || generateId();
        this.tags = data.tags || [];
        this.title = data.title;
        this.timestamp = data.timestamp;
        this.value = data.value;
        this.valueDisplay = data.valueDisplay;
        this.notes = data.notes || '';
        this.latitude = data.latitude;
        this.longitude = data.longitude;
        this.locationName = data.locationName;
        this.isArchived = data.isArchived;
        this.createdAt = data.createdAt || new Date().toISOString();
    }

    /**
     * Create entry from form data with tags
     */
    static fromFormData(formData: EntryFormData, tagsToAdd: Tag[]): Entry {
        const tags: IEntryTag[] = tagsToAdd.map(tag => ({
            id: generateId(),
            tagId: tag.id,
            tagName: tag.name,
            createdAt: new Date().toISOString()
        }));

        return new Entry({
            tags,
            title: formData.title,
            timestamp: new Date(formData.timestamp).toISOString(),
            value: formData.value,
            valueDisplay: formData.valueDisplay,
            notes: formData.notes?.trim() || '',
            latitude: formData.latitude,
            longitude: formData.longitude,
            locationName: formData.locationName
        });
    }

    /**
     * Get all tag IDs for this entry
     */
    get tagIds(): string[] {
        return this.tags.map(t => t.tagId);
    }

    /**
     * Get all tag names for this entry
     */
    get tagNames(): string[] {
        return this.tags.map(t => t.tagName);
    }

    /**
     * Check if entry has a specific tag
     */
    hasTag(tagId: string): boolean {
        return this.tags.some(t => t.tagId === tagId);
    }

    /**
     * Get first tag (for backwards compatibility in UI)
     */
    get primaryTag(): IEntryTag | undefined {
        return this.tags[0];
    }

    validate(): string[] {
        const errors: string[] = [];

        if (!this.tags || this.tags.length === 0) {
            errors.push('At least one tag is required');
        }

        if (!this.title || this.title.trim() === '') {
            errors.push('Title is required');
        }

        if (!this.timestamp) {
            errors.push('Timestamp is required');
        }

        return errors;
    }

    toJSON(): IEntry {
        return {
            id: this.id,
            tags: this.tags,
            title: this.title,
            timestamp: this.timestamp,
            value: this.value,
            valueDisplay: this.valueDisplay,
            notes: this.notes,
            latitude: this.latitude,
            longitude: this.longitude,
            locationName: this.locationName,
            isArchived: this.isArchived,
            createdAt: this.createdAt
        };
    }
}
