import { generateId } from '../utils/helpers.js';
import { IEntity, EntityType, EntityFormData, ValueType, SelectOption, EntityProperty } from '../types/index.js';

/**
 * Maps entity types to their default value types
 */
export function getDefaultValueType(entityType: EntityType): ValueType {
  const mapping: Record<EntityType, ValueType> = {
    'Habit': 'checkbox',         // Binary yes/no tracking
    'Metric': 'number',          // Numeric measurements
    'Task': 'select',            // Status-based workflow
    'Note': 'text',              // Freeform text logging
    'Event': 'datetime-local',   // Time-based occurrences
    'Resource': 'hyperlink',     // External references (URLs)
    'Decision': 'select'         // Choice tracking
  };
  return mapping[entityType];
}

/**
 * Get default options for select value types based on entity type
 */
export function getDefaultSelectOptions(entityType: EntityType): SelectOption[] | undefined {
  const optionsMapping: Partial<Record<EntityType, SelectOption[]>> = {
    'Task': [
      { value: 'todo', label: 'To Do' },
      { value: 'in-progress', label: 'In Progress' },
      { value: 'done', label: 'Done' }
    ],
    'Decision': [
      { value: 'yes', label: 'Yes' },
      { value: 'no', label: 'No' },
      { value: 'pending', label: 'Pending' }
    ]
  };
  return optionsMapping[entityType];
}

/**
 * Entity model representing a trackable item
 */
export class Entity implements IEntity {
  id: string;
  name: string;
  type: EntityType;
  categories: string[];
  valueType?: ValueType;
  options?: SelectOption[];
  properties?: EntityProperty[];
  createdAt: string;

  constructor(data: Partial<IEntity> & { name: string; type: EntityType }) {
    // ID will be generated by the server if not provided
    this.id = data.id || generateId();
    this.name = data.name;
    this.type = data.type;
    this.categories = data.categories || [];
    this.valueType = data.valueType;
    this.options = data.options;
    this.properties = data.properties || [];
    this.createdAt = data.createdAt || new Date().toISOString();
  }

  static fromFormData(formData: EntityFormData): Entity {
    return new Entity({
      name: formData.name.trim(),
      type: formData.type,
      categories: formData.categories
        ? formData.categories.split(',').map(c => c.trim()).filter(c => c)
        : []
    });
  }

  validate(): string[] {
    const errors: string[] = [];

    if (!this.name) {
      errors.push('Name is required');
    }

    const validTypes: EntityType[] = ['Habit', 'Metric', 'Task', 'Note', 'Event', 'Resource', 'Decision'];
    if (!this.type || !validTypes.includes(this.type)) {
      errors.push('Valid type is required');
    }

    return errors;
  }

  toJSON(): IEntity {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      categories: this.categories,
      valueType: this.valueType,
      options: this.options,
      properties: this.properties,
      createdAt: this.createdAt
    };
  }
}
